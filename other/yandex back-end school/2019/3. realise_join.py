# Даны две таблицы T1 и T2. Каждая таблица представлена двумя числовыми полями.
# Таблица T1 содержит поля a и b. Таблица T2 содержит поля a и c.
#
# Необходимо реализовать упрощённую вариацию SQL JOIN двух таблиц по полю a и сформировать таблицу T3.
#
# Значения поля a в таблице могут дублироваться, но количество дублирований каждого поля не превышает 5.
# Ограничение времени: 1 с, ограничение памяти: 64 Мб.
###
# Формат ввода:
# В первой строке входных данных записано целое число n1 (1 ≤ n1 ≤ 15000) – количество строк в таблице T1.
# Далее в n1 строках записаны через пробел по два целых числа — значения полей ai и bi (1 ≤ ai, bi ≤ 1000) таблицы T1.
# В следующей строке записано целое число n2 (1 ≤ n2 ≤ 10000) – количество строк в таблице T2.
# Далее в n2 строках записаны через пробел по два целых числа — значения полей aj и cj (1 ≤ aj, cj ≤ 1000) таблицы T2.
# Последняя строка — название операции (INNER, LEFT, RIGHT, FULL).
#
# Формат вывода:
# В первой строке выведите число n3 — количество строк в таблице T3.
# В следующих n3 строках выведите через пробел значения полей ak, bk и ck таблицы T3.
# Если в результате соединения таблиц значение какого-либо поля отсутствует, выведите NULL вместо этого поля.
# Порядок вывода строк таблицы T3 не важен.

pass

# Решение:
# Для начала разберем случай, когда все a уникальны. Наивное решение — пройтись вложенным циклом по обеим таблицам:
#   for a1, b in t1:
#     for a2, c in t2:
#         if a1 == a2:
#             t3.append((a1, b, c))
# Такое решение неоптимально и не пройдет по ограничениям времени.
# Нужен более быстрый способ проверять наличие в таблице строки с определенным значением поля a.
# Можно воспользоваться хэш-таблицами:
#   for row in t1:
#     t1_map[row[0]] = row
# Теперь реализуем операцию LEFT. Проходя по ключам первой таблицы, проверяем,
# встречается ли такой ключ во второй таблице.
# Если встречается — добавляем в итоговую таблицу строку (a, b, c), если нет — (a, b, NULL).
#   for a, b in t1_map.items():
#      if a in t2_map:
#          t3.append((a, b, t2[a]))
#      else:
#          t3.append((a, b, 'NULL'))
# Для реализации RIGHT можно поменять порядок таблиц.
#
# Для реализации FULL нужно сделать дополнительный проход уже по другой таблице,
# добавив значения, которые не встречаются в первой таблице:
# for a, c in t2_map.items():
#     if a not in t1_map:
#         t3.append((a, 'NULL', c))
# Если a не уникально, необходимо немного изменить структуру hash-map
# и хранить в качестве значений список соответствующих строк,
# а в результирующую таблицу добавлять декартово произведение строк с одинаковым полем a.
# В Python для этого можно воспользоваться itertools.product.
#
# Стоит заметить, что когда значения поля a во всех строках обеих таблиц совпадает,
# мы получим размер выходной таблицы — N x N.
# Но в условии сказано, что таких повторений не более пяти для каждого значения.
# Значит, свойство неуникальности не сильно скажется на сложности нашего алгоритма.
