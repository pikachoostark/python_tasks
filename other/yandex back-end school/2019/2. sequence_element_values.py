# Последовательность f0, f1, f2, ... задана рекуррентными соотношениями f0 = 0, f1 = 1, f2 = 2, fk = fk-1 + fk-3.
# Напишите программу, которая вычисляет n элементов этой последовательности с номерами k1, k2, ..., kn.
# Ограничение времени: 1 с, ограничение памяти: 10 Мб.
###
# Формат ввода:
# В первой строке входных данных записано целое число n (1 ≤ n ≤ 1_000)
# Во второй строке записаны n целых неотрицательных чисел (0 ≤ ki ≤ 16_000), разделённых пробелами.
#
# Формат вывода:
# Выведите через пробел значения fk1, fk2, ..., fkn.
n = int(input())
k = list(map(int, input().split()))
fk = [0, 1, 2]
counter = 2

while counter != max(k):
    counter += 1
    fk.append(fk[counter-1] + fk[counter-3])

print(' '.join(str(fk[i]) for i in k))

# Решение:
# В задаче нужно было не только подобрать оптимальный по времени алгоритм,
# но и использовать как можно меньше дополнительной памяти.
# Большинство присланных решений не уложились в ограничения по времени или по памяти.
#
# Заметим, что для вычисления fk необходимо вычислить f0, f1, ..., fk–1.
# Поэтому достаточно вычислить fk, где k = max(k1, k2, ..., kn).
# Кроме того, для вычисления нужны лишь и fk–1 и fk–3,
# поэтому в дополнительной памяти достаточно хранить только три последних вычисленных значения,
# а также значения, которые нужно вернуть в качестве ответа.
#
# Решение требует O(max(k, n)) времени и O(n) дополнительной памяти.
# n = int(input())
# indices = [int(i) for i in input().split()]
# results = {i: i if i < 3 else None for i in indices}
# k = max(indices)
# a, b, c = 0, 1, 2
# for i in range(3, k + 1):
#     a, b, c = b, c, a + c
#     if i in results:
#         results[i] = c
# print(" ".join(str(results[i]) for i in indices))
